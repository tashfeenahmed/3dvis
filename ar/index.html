<!DOCTYPE html>
<html>
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />

        <title>Babylon.js sample code</title>

        <!-- Babylon.js -->
        <script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.6.2/dat.gui.min.js"></script>
        <script src="https://preview.babylonjs.com/ammo.js"></script>
        <script src="https://preview.babylonjs.com/cannon.js"></script>
        <script src="https://preview.babylonjs.com/Oimo.js"></script>
        <script src="https://preview.babylonjs.com/earcut.min.js"></script>
        <script src="https://preview.babylonjs.com/babylon.js"></script>
        <script src="https://preview.babylonjs.com/materialsLibrary/babylonjs.materials.min.js"></script>
        <script src="https://preview.babylonjs.com/proceduralTexturesLibrary/babylonjs.proceduralTextures.min.js"></script>
        <script src="https://preview.babylonjs.com/postProcessesLibrary/babylonjs.postProcess.min.js"></script>
        <script src="https://preview.babylonjs.com/loaders/babylonjs.loaders.js"></script>
        <script src="https://preview.babylonjs.com/serializers/babylonjs.serializers.min.js"></script>
        <script src="https://preview.babylonjs.com/gui/babylon.gui.min.js"></script>
        <script src="https://preview.babylonjs.com/inspector/babylon.inspector.bundle.js"></script>

        <style>
            html, body {
                overflow: hidden;
                width: 100%;
                height: 100%;
                margin: 0;
                padding: 0;
            }

            #renderCanvas {
                width: 100%;
                height: 100%;
                touch-action: none;
            }
        </style>
    </head>
<body>
    <canvas id="renderCanvas"></canvas>
    <script>
        var canvas = document.getElementById("renderCanvas");

        var engine = null;
        var scene = null;
        var sceneToRender = null;
        var createDefaultEngine = function() { return new BABYLON.Engine(canvas, true, { preserveDrawingBuffer: true, stencil: true,  disableWebGL2Support: false}); };
        // Marker locations: https://syntheticmagus.github.io/webpiled-aruco-ar/markers/
        
        const MIRROR_AR = false;
        const ARUCO_MODULE_NAME = "acuroModule";
        const ARUCO_MODULE_LOCATION = "https://syntheticmagus.github.io/webpiled-aruco-ar/v0.01/webpiled-aruco-ar.js";
        const FILTER_STRENGTH = 0.4;
        
        // TODO: Allow the use of other ArUco marker dictionaries.
        // TODO: Do the aruco stuff in a WebWorker?
        function ensureAruco() {
            if (document.getElementById(ARUCO_MODULE_NAME) === null) {
                var moduleScript = document.createElement("script");
                moduleScript.id = ARUCO_MODULE_NAME;
                moduleScript.src = ARUCO_MODULE_LOCATION;
                document.body.appendChild(moduleScript);
            }
        }
        
        function findMarkersInImage(videoTexture, callback) {
            var width = videoTexture.getSize().width;
            var height = videoTexture.getSize().height;
            var imageData = videoTexture.readPixels();
        
            var buf = Module._malloc(imageData.length * imageData.BYTES_PER_ELEMENT);
            Module.HEAPU8.set(imageData, buf);
            var numMarkers = Module._process_image(width, height, buf, 1);
            Module._free(buf);
        
            for (var markerIdx = 0; markerIdx < numMarkers; markerIdx++) {
                var ptr = Module._get_tracked_marker(0);
        
                var offset = 0;
                var id = Module.getValue(ptr + offset, "i32");
                offset += 12;
                var tx = Module.getValue(ptr + offset, "double");
                offset += 8;
                var ty = Module.getValue(ptr + offset, "double");
                offset += 8;
                var tz = Module.getValue(ptr + offset, "double");
                offset += 8;
                var rx = Module.getValue(ptr + offset, "double");
                offset += 8;
                var ry = Module.getValue(ptr + offset, "double");
                offset += 8;
                var rz = Module.getValue(ptr + offset, "double");
        
                if (callback) {
                    callback(id, tx, ty, tz, rx, ry, rz);
                }
            }
        
            return numMarkers;
        }
        
        var createScene = function () {
            var scene = new BABYLON.Scene(engine);
            var camera = new BABYLON.FreeCamera('camera1', new BABYLON.Vector3(0, 0, 0), scene);
            var light = new BABYLON.HemisphericLight('light1', new BABYLON.Vector3(0, 1, 0), scene);
        
            // TODO: Codify the placement of this plane to automatically adapt to camera parameters.
            var ground = BABYLON.Mesh.CreatePlane("ground1", 220, scene);
            ground.position.z = 1000;
            ground.scaling.x = MIRROR_AR ? -4 : 4;
            ground.scaling.y = -3; // Handedness
        
            var mat = new BABYLON.StandardMaterial("mat", scene);
            ground.material = mat;
        
            BABYLON.SceneLoader.ImportMeshAsync("", "https://raw.githubusercontent.com/BabylonJS/MeshesLibrary/master/BabylonJS-logo/v3/babylonJS_logo_solid_v3.babylon").then(function (result) {
                var box = result.meshes[0];
                box.rotationQuaternion = BABYLON.Quaternion.Identity();
        
                ensureAruco();
                BABYLON.VideoTexture.CreateFromWebCam(scene, function (videoTexture) {
                    mat.diffuseTexture = videoTexture;
        
                    setTimeout(function () {
                        Module._reset();
        
                        var ftx = 0.0;
                        var fty = 0.0;
                        var ftz = 0.0;
                        var frx = 0.0;
                        var fry = 0.0;
                        var frz = 0.0;
        
                        var framesSinceSeen = 0;
        
                        scene.onAfterRenderObservable.add(function () {
                            var numMarkers = findMarkersInImage(videoTexture, function (id, tx, ty, tz, rx, ry, rz) {
                                ftx = MIRROR_AR ? -tx : tx;
                                fty = -ty; // Handedness.
                                ftz = tz;
        
                                frx = rx;
                                fry = ry;
                                frz = rz;
                            });
        
                            // Convert rotations from Rodrigues to quaternion and filter noise.
                            // TODO: The noise on the rotation looks like it toggles between right answers and wrong answers.
                            // User a median filter to improve the quality.
                            var rot = new BABYLON.Vector3(-frx, fry, -frz);
                            var theta = rot.length();
                            rot.scaleInPlace(1.0 / theta);
                            if (theta !== 0.0) {
                                var quat = BABYLON.Quaternion.RotationAxis(rot, theta);
                                box.rotationQuaternion = BABYLON.Quaternion.Slerp(box.rotationQuaternion, quat, 1.0 - FILTER_STRENGTH);
                            }
        
                            if (numMarkers === 0) {
                                framesSinceSeen += 1;
                            }
                            else {
                                framesSinceSeen = 0;
                            }
        
                            box.position.x *= FILTER_STRENGTH;
                            box.position.x += (1.0 - FILTER_STRENGTH) * ftx;
                            box.position.y *= FILTER_STRENGTH;
                            box.position.y += (1.0 - FILTER_STRENGTH) * fty;
                            box.position.z *= FILTER_STRENGTH;
                            box.position.z += (1.0 - FILTER_STRENGTH) * ftz;
        
                            if (framesSinceSeen < 10 || Math.abs(box.position.x - ftx) > 0.01) {
                                for (var idx = 0; idx < result.meshes.length; idx++) {
                                    result.meshes[idx].visibility = 1;
                                }
                            }
                            else {
                                for (var idx = 0; idx < result.meshes.length; idx++) {
                                    result.meshes[idx].visibility = 0;
                                }
                            }
                        });
                    }, 2000); // TODO: Find a better way to wait for the ArUco module to load.
                }, { maxWidth: 640, maxHeight: 480 });
            });
        
            return scene;
        };
                window.initFunction = async function() {
                    
                    var asyncEngineCreation = async function() {
                        try {
                        return createDefaultEngine();
                        } catch(e) {
                        console.log("the available createEngine function failed. Creating the default engine instead");
                        return createDefaultEngine();
                        }
                    }

                    window.engine = await asyncEngineCreation();
        if (!engine) throw 'engine should not be null.';
        window.scene = createScene();};
        initFunction().then(() => {sceneToRender = scene        
            engine.runRenderLoop(function () {
                if (sceneToRender && sceneToRender.activeCamera) {
                    sceneToRender.render();
                }
            });
        });

        // Resize
        window.addEventListener("resize", function () {
            engine.resize();
        });
    </script>
</body>
</html>
